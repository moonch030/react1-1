# REACT1-1
## 문채현 202230310
https://github.com/soaple/first-met-react-practice-v18
---
### 2024-05-08 강의내용
### 이벤트 핸들링
#### 이벤트 핸들러 추가하는 방법
- 버튼을 클릭하면 이벤트 핸들러 함수인 handleClick()함수를 호출   
- bind를 사용하지 않으면 this.handleClick은 글로벌 스코프에서 호출되어, undefined으로 사용할 수 없기 때문   
- bind를 사용하지 않으려면 화살표 함수를 사용하는 방법도 있음.   
- 하지만 클래스 컴포넌트는 이제 거의 사용하지 않기 때문에 이 내용은 참고만...   
- 함수형에서는 this를 사용하지 않고, onClick에서 바로 HandleClick을 넘기면 된다.   
#### 8.2 Arguments 전달하기
- 함수를 정의할 때는 파라미터 혹은 매개변수, 함수를 사용할때는 아규먼트 혹은 인수라고 부른다.   
- 이벤트 핸들러에 매개변수를 전달해야 하는 경우도 많음.   
```
<button onClick={(event) => this.deleteItem(id,event)}>삭제하기</button>
<button onClick={this.deleteItem.bind(this.id)}>삭제하기</button>
```
- 위의 코드는 모두 동일한 역할을 하지만 하나는 화살표 함수, 다른 하나는 bind를 사용 했음.   
- event라는 매개변수는 리액트의 이벤트 객체를 말함   
- 두 방법 모두 첫 번째 매개변수는 id 이고 두 번째 매개변수로 event가 전달.   

---
### 2024-05-01 강의 내용
### ch07 훅
### 훅의 규칙
- `두번째 규칙`은 `함수형 컴포넌트에서만 훅을 호출`해야 한다는 것.   
- 따라서 일반 자바스크립트 함수에서 훅을 호출하면 안됨.   
- 훅은 `함수형 컴포넌트` 혹은 직접 만든 `커스텀 훅에서만 호출`할 수 있음.
### 나만의 훅 만들기
- 필요하다면 직접 훅을 만들어 쓸 수도 있음. 이것을 `커스텀 훅`이라고 함.   
1. 커스텀 훅을 만들어야 하는 상황   
예제 UserStatus 컴포넌트는 isOnline이라는 state에 따라서 사용자의 상태가 온라인인지 아닌지를 텍스트로 보여주는 컴포넌트
```
import React, {useState, useEffect} from "react";

function UserStatus(props){
    const [isOnline, setIsOnline] = useState(null);

    useEffect(() => {
        function handleStatusChange(status){
            setIsOnline(status.isOnline);
        }

        ServerAPI.subscribeUserStatus(props.user.id, handleStatusChange);
        return () => {
            ServerAPI.unsubscribeUserStatus(props.user.id,handleStatusChange);
        }
    });
    if(isOnline === null){
        return '대기중...';
    }
    return isOnline ? '온라인' : '오프라인';
}
```
### 이벤트 핸들링
- DOM에서 클릭 이벤트를 처리하는 예제 코드
```
<button onclick = "activate()">
    Activate
</button>
```
- React에서 클릭 이벤트 처리하는 예제 코드
```
<button onClick={activate}>
    Activate
</button>
```
- 둘의 차이점은   
1) 이벤트 이름이 onclick에서 onClick으로 변경
2) 전달하려는 함수는 문자열에서 함수 그대로 전달.   
- 이벤트가 발생했을 때 이벤트를 처리하는 함수를 `이벤트 핸들러` 라고 한다. 또는 이벤트가 발생하는 것을 계속 듣고 있다는 의미로 `이벤트 리스너`라고 부르기도 한다.   
- `이벤트 핸들러 추가하는 방법은?`
- 버튼을 클릭하면 이벤트 핸들러 함수인 handleClick()함수를 호출   
- bind를 사용하지 않으면 this.handleClick은 글로벌 스코프에서 호출되어, undefined으로 사용할 수 없기 때문   
- bind를 사용하지 않으려면 화살표 함수를 사용하는 방법도 있음.   
- 하지만 클래스 컴포넌트는 이제 거의 사용하지 않기 때문에 이 내용은 참고만...
---
### 2024-04-17 강의 내용
### ch07 훅
### 1. 훅이란 무엇인가?
- `클래스형 컴포넌트`에서는 생성자(constructor)에서 state를 정의하고, setState() 함수를 통해 state를 업데이트 한다.   
- `예전에 사용하던 함수형 컴포넌트`는 별도로 state를 정의하거나, 컴포넌트의 생명주기에 맞춰서 어떤 코드가 실행되도록 할 수 없었다.      
- 함수형 컴포넌트에서도 state나 생명주기 함수의 기능을 사용하게 해주기 위해 추가된 기능이 `훅(Hook)`이다.   
- 함수형 컴포넌트도 훅을 사용하여 클래스형 컴포넌트의 기능을 모두 `동일하게 구현`할 수 있게 되었다.   
- Hook이란 `state와 생명주기 기능에 갈고리를 걸어 원하는 시점에 정해진 함수를 실행되도록 만든 함수`를 의미한다.   
- 훅의 이름은 모두 `use`로 시작한다.   
- 사용자 정의 훅(custom hook)을 만들 수 있으며, 이 경우에 이름은 자유롭게 할 수 있으나 `use`로 시작할 것을 권장한다.   
### 2. useSate
- useState는 함수형 컴포넌트에서 state를 사용하기 위한 Hook 이다.   
- 다음 예제는 버튼을 클릭할 때마다 카운트가 증가하는 함수형 컴포넌트다.   
- 하지만 증가는 시킬 수 있지만 증가할 때마다 재 렌더링은 일어나지 않는다.   
- 이럴 때 state를 사용해야 하지만 함수형에는 없기 때문에 useState()를 사용한다.   
```
import React, {useState} from "react"

export default function Counter(Props){
    const [count, setCount] = useState(0)
    return (
        <>
            <p>총 {count}번 클릭했습니다.</p>
            <button onClick={() => setCount(count++)}>클릭</button>
        </>
    )
}
```
### 3. useEffect
- `useState`와 함께 가장 많이 사용하는 Hook 이다.   
- 이 함수는 `사이드 이펙트`를 수행하기 위한 것이다.   
- 영어로 side effect는 부작용을 의미한다. 일반적으로 프로그래밍에서 사이트 이펙트는 `개발자가 의도하지 않은 코드가 실행되면서 버그가 발생하는것`을 의미   
- 하지만 리액트 에서는 효과 또는 영향을 뜻하는 effect의 의미에 가까움.   
- 예를 들면 서버에서 데이터를 받아오거나 수동으로 DOM을 변경하는 등의 작업을 의미   
- 이 작업을 이펙트라고 부르는 이유는 이 작업들이 다른 컴포넌트에 영향을 미칠 수 있으며, `렌더링중에는 작업이 완료될 수 없기 때문`이다.   렌더링이 끝난 이후에 실행되어야 하는 작업들이다.   
- `클래스 컴포넌트의 생명주기 함수와 같은 기능을 하나로 통합한 기능을 제공`    
- 결국 sideEffect는 렌더링 외에 실행해야 하는 부수적인 코드를 말한다.   
- 예를 들면 네트워크 리퀘스트, DOM 수동 조작, 로깅 등은 정리(clean-up)가 필요 없는 경우들이다.   
#### useEffect()함수는 다음과 같이 사용해야 한다.
- 첫 번째 파라미터는 `이펙트 함수`가 들어가고 두 번째 파라미터로는 `의존성 배열`이 들어간다.   

```
useEffect(이펙트 함수, 의존성 배열);
```
- 의존성 배열은 이펙트가 의존하고 있는 배열로 `배열 안에 있는 변수 중에 하나라도 값이 변경되었을 때 이펙트 함수`가 실행된다.   
- 이펙트 함수는 `처음 컴포넌트가 렌더링 된 이후` 그리고 `재 렌더링 이후`에  실행된다.   
- 만약 이펙트 함수가 `마운트와 언마운트 될 때만 한 번씩 실행`되게 하고 싶으면 `빈 배열`을 넣으면 된다. 이 경우 props나 state에 있는 어떤 값에도 의존하지 않기 때문에 여러 번 실행되지 않는다.   

### 4. useMemo
- userMemo() 훅은 Memoizde value를 리턴하는 훅이다.   
- 이전 계산값을 가지고 있기 때문에 연산량이 많은 작업의 반복을 피할 수 있다.   
- 이 훅은 렌더링이 일어나는 동안 실행된다.   
- 따라서 렌더링이 일어나느 동안 실행돼서는 안 될 작업을 넣으면 안된다.   
- 예를 들면 useEffect에서 실행되어야 할 사이드 이팩트 같은것.
```
const memoizedValue = useMemo(
    () => {
        //연산량이 높은 작업을 수행하여 결과를 반환
        return computeExpensiveValue(의존성 변수1, 의존성 변수2);
    },
    [의존성 변수1, 의존성 변수2]
)

```
#### 다음 코드와 같이 의존성 배열을 넣지 않을 경우, 렌더링이 일어날 때마다 매번 함수가 실행된다.
#### 따라서 의존성 배열을 넣지 않는 것은 의미가 없다. 
#### 만약 빈 배열을 넣게 되면 컴포넌트 마운트 시에만 함수가 실행된다.
```
const memoizedValue = useMemo(
    () => computeExpensiveValue(a,b)
);
```
### 5. useCallback
- useCallback() 훅은 useMemo()와 유사한 역할이다.   
- 차이점은 `값이 아닌 함수를 반환 한다는 점` 이다.   
- 의존성 배열을 파라미터로 받는 것은 useMemo와 동일하다.   
- 파라미터로 받은 함수를 콜백 이라고 한다.   
- useMemo와 마찬가지로 의존성 배열 중 하나라도 변경되면 콜백 함수를 반환한다.   
```
const memoizedCallback = useCallback(
    ()=> {;
        doSomething(의존성 변수1, 의존성 변수2);
    },
    [의존성 변수1, 의존성 변수2]
)
```
### 6. useRef
- useRef() 훅은 레퍼런스를 사용하기 위한 훅이다.   
- 레퍼런스란 `특정 컴포넌트에 접근할 수 있는 객체`를 의미한다.   
- useRef() 훅은 바로 이 레퍼런스 객체를 반환한다.   
- 레퍼런스 객체에는 .current라는 속성이 있는데, 이것은 현재 참조하고 있는 엘리먼트를 의미한다.
```
const refContainer = useRef(초기값);
```
- 이렇게 반환 된 레퍼런스 객체는 컴포넌트의 라이프타임 전체에 걸쳐서 유지된다.   
- 즉, 컴포넌트가 마운트 해제 전까지는 계속 유지된다는 의미   

### 7. 훅의 규칙
- 첫 번째 규칙은 무조건 `최상의 레벨에서만 호출`해야 한다는 것이다. 여기서 최상위는 컴포넌트의 최상위 레벨을 의미한다.   
- 따라서 반복문이나 조건문 또는 중첩 된 함수들 안에서 훅을 호출하면 안된다.   
- 이 규칙에 따라서 훅은 컴포넌트가 렌더링 될 때마다 같은 순서로 호출 되어야 한다.   
---
### 2024-04-02 강의 내용
### 1. 컴포넌트에 대해 알아보기
- 리액트는 컴포넌트 기반의 구조   
- 컴포넌트 구조란? 작은 컴포넌트가 모여 큰 컴포넌트를 구성하고, 다시 이런 컴포넌트들이 모여서 전체 페이지를 구성한다는것을 의미   
- 전체 코드의 양을 줄일 수 있어 개발 시간과 유지보수 비용을 줄임  
- 컴포넌트는 자바스크립트 함수처럼 입력과 출력이 있음   
- 다만 입력은 Props가 담당, 출력은 리액트 엘리먼트의 형태로 출력

#### 1. Props의 개념
- property : 속성, 특성   
- 어떤 속성, props를 넣느냐에 따라서 속성이 다른 엘리먼트가 출력됨   
- props는 컴포넌트에 전달 할 다양한 정보를 담고 있는 자바스크립트 객체   
- ex) 에어비엔비    

#### 2. Props의 특징   
- 읽기 전용 / 변경 X   
- 속성이 다른 엘리먼트를 생성하려면 새로운 props를 컴포넌트에 전달   

#### Pure함수 vs Impure 함수   
- Pure 함수는 인수로 받은 정보가 함수 내부에서도 변하지 않는 함수   
- Impure 함수는 불순한 컴포넌트는 외부의 상태를 변경하거나 DOM 가 상호작용하거나 네트워크의 요청을 보내는 등의 부작용이 있다. 그것들은 아마 같은 인풋을 받고 자신의 현재 상태나 앱의 상태에 따라서 다른 아웃풋을 반환할 것이다. 그 결과, 테스트와 디버그 하기에 훨씬 더 어려울수가있음.   

#### 3. Props 사용법
- JSX에서는 key_value쌍으로 props를 구성   

```
function App(props){
    return(
        <Profile
            name="소플"
            introduction="안녕하세요, 소플입니다."
            viewCount={1500}
            />
    );
}
```

위의 코드는   
1. App 컴포넌트에서 props를 인자로 받아,   
2. 내부의 Profile 컴포넌트를 전달해서 name, introdcution, viewCount에 각각 속성을 할당하는,   
3. 이때 전잘되는 props는 다음과 같은 자바스크립트 객체임

```
{
    name:"소플"
    introduction:"안녕하세요, 소플입니다.",
    viewCount:1500
}
```

- JSX에서는 중괄호를 사용하면 JS코드를 넣을 수 있음   
- 다음 코드처럼 props를 통해서 value를 할당 할 수도 있고, 직접 중괄호를 사용하여 할당할 수도 있음   
- JSX를 사용하지 않는 경우 props의 전달 방법은 createElement() 함수를 사용하는 것   
- createElement() 함수의 두번째 매개변수가 바로 props임   

#### 1. 컴포넌트의 종류   
- 초기 버전을 사용할 때는 클래스형 컴포넌트를 주로 사용   
- 이후 Hook이라는 개념이 나오면서 최근에는 함수형 컴포넌트를 주로 사용   
- 예전에 작성된 코드나 문서들이 클래스형 컴포넌트를 사용하고 있기 때문에, 클래스형 컴포넌트와 컴포넌트의 생명주기에 관해서도 공부 해야함.   

#### 2. 함수형 컴포넌트
- Welcome컴포넌트는 props를 받아, 받은 props중 name키의 값을 "안녕," 뒤에 넣어 반환   

#### 3. 클래스형 컴포넌트
- Welcome컴포넌트는 React.Component class로부터 상속을 받아 선언

#### 4. 컴포넌트 이름 짓기
- 이름은 항상 대문자 시작   
- 리액트는 소문자로 시작하는 컴포넌트를 DOM 태그로 인식. html tag.   
- 컴포넌트 파일 이름과 컴포넌트 이름은 같게

#### 5. 컴포넌트의 렌더링
- 렌터링의 과정은 다음 코드와 같습니다.

```
function Welcome(props){
    return <h1>안녕, {props.name}</h1>;
}

const element=<Welcome name="인제"/>;
ReactDom.render(
    element,
    document.getElementById('root')
);
```
#### 6. 컴포넌트 합성
- 컴포넌트 합성은 여러 개의 컴포넌트를 합쳐서 하나의 컴포넌트를 만드는 것   
- 리액트에서는 컴포넌트 안에 또 다른 컴포넌트를 사용할 수 있기 때문에, 복잡한 화면을 여러개의 컴포넌트로 나누어 구현 가능   
- 다음 코드에서는 props의 값을 다르게 해서 welcome컴포넌트를 여러번 사용   
```
function Welcome(props){
    return <h1>Hello, {props.name}</h1>;
}

function App(props){
    return(
        <div>
            <Welcome name="인제"/>
            <Welcome name="순신"/>
            <Welcome name="강감찬"/>
        </div>
    )
}

ReactDom.render(
    <App/>,
    document.getElementById('root');
)
```
#### 7. 컴포넌트 추출
- 복잡한 컴포넌트를 쪼개서 여러 개의 컴포넌트로 나눌 수도 있음   
- 큰 컴포넌트에서 일부를 추출해서 새로운 컴포넌트를 만드는 것   
- 실무에서는 처음부터 1개의 컴포넌트에 하나의 기능만 사용하도록 설계   
- comment는 댓글 표시 컴포넌트  
- 내부에는 이미지, 이름, 댓글과 작성일이 포함   

### 2. State
#### 1. State란?
- state는 리액트 컴포넌트의 상태를 의미   
- 상태의 의미는 정상인지 비정상인지가 아니라 컴포넌트의 데이터를 의미   
- 정확히는 컴포넌트의 변경 가능한 데이터를 의미   
- state가 변하면 다시 렌더링이 되기 때문에 렌더링과 관련된 값만 state에 포함 시켜야 함   

#### 2. state 특징
- 변경은 가능하지만 직접 수정은 X   
- state를 변경하고자 할 때는 setstate()함수 사용   

```
//state를 직접 수정 (잘못된 사용법)
this.state={
    name:'Moon'
};
```
#### 3. 생명주기
- 생명주기는 컴포넌트의 생성 시점, 사용 시점, 종료 시점을 나타냄   
- constructor가 실행. 되면서 컴포넌트가 생성   
- 생성 직후 componentDidMount() 함수가 호출됨   
- 컴포넌트가 소멸하기 전까지 여러번 렌더링   
- 렌더링은 props, setState(), forceUpdate() 에 의해 상태가 변경되면 이루어짐   
- 그리고 렌더링이 끝나면 componentDinUpdate() 함수가 호출됨   
- 마지막으로 컴포넌트가 언마운트 되면 compomentWillUnmount() 함수가 호출됨   


---
### 2024-03-27 강의 내용
### 1. JSX(JavaScript XML)란?
- JavaScript에 XML을 추가한 확장 문법   
- 리액트는 컴포넌트를 태그화   
- JSX의 역할   
-> JSX는 내부적으로 XML/HTML 코드를 자바스크립트로 변환   
-> React가 createElement함수를 사용하여 자동으로 자바스크립트로 변환   
-> 만일 JS작업 할 경우 직접 createElement함수를 사용   
-> 가독성을 높여주는 역할  
- JSX의 장점
-> 코드가 간결해짐   
-> 가독성 향상   
-> Injection Attack이라 불리는 해킹 방법을 방어함으로써 보안에 강함   

- JSX 사용법   
-> 모든 자바스크립트 문법 지원   
-> 자바스크립트 문법에 XML과 HTML을 섞어서 사용   
-> html이나 xml에 자바스크립트 코드를 사용하고 싶으면 {} 괄호 사용   
-> 태그의 속성값을 넣고 싶을때는 아래와 같이 사용

``` 
큰따옴표 사이에 문자열을 넣거나   
const element = <div tabIndex="0"></div>;   
중괄호 사이에 자바스크립트 코드를 넣으면 됨
const element = <img src={user.avatarUrl}></img>;
```
### 2. 엘리먼트 정의   
-> 리액트 앱을 구성하는 요소   
-> "엘리먼트는 리액트 앱의 가장 작은 빌딩 블록들"   
-> 웹사이트 경우 DOM 엘리먼트이며 HTML 요소를 의미

- **리액트 엘리먼트와 DOM엘리먼트 차이**(잘 알기)   
-> 리액트 엘리먼트는 Virtual DOM의 형태를 취함   
-> DOM 엘리먼트는 페이지의 모든 정보를 갖고 있어 무거움   
-> 반면 리액트 엘리먼트는 변화한 부분만 갖고 있어 가벼움  

- 엘리먼트의 생김새   
-> 리액트 엘리먼트는 자바스크립트 객체의 형태로 존재   
-> 컴포넌트(Button 등), 속성(color 등) 및 내부의 모든 children을 포함하는 일반 JS객체   
-> 이 객체는 마음대로 변경할 수 없는 불변성을 가지고 있음   

- 엘리먼트 정의   
-> 리액트 엘리먼트의 가장 큰 특징은 불변성 즉, 한 번 생성 된 엘리먼트의 chlidern이나 속성(attributes)를 바꿀 수 없음  

-> 내용이 바뀐다면 ?
1. 컴포넌트를 통해 새로운 엘리먼트 생성   
2. 이전 엘리먼트와 교체하는 방법을 내용을 바꿈   
3. 교체하는 작업을 하기 위해 Virtual DOM을 사용   

- Root DOM node   
-> 다음 html 코드는 id 값이 root 인 div태그로 단순하지만 리액트에 필수로 들어가는 아주 중요한 코드입니다.   
이 div 태그 안에 리액트 엘리먼트가 렌더링 되며, 이 것을 root DOM node 라고 합니다.
```
01 <div id="root"></div>
```
엘리먼트를 렌더링 하기 위해서는 다음과 같은 코드가 필요합니다.   
```
01 const element = <h1>안녕, 리액트!</h1>;
02 ReactDOM.render(element, document.getElementById('root'));
```
이때 render() 함수를 사용하게 됩니다.   
이 함수의 첫 번째 파라미터 출력 할 리액트 엘리먼트이고, 두 번째 파라미터는 출력 할 타겟을 나타냅니다.   
**"즉, 리액트 렌더링의 과정은 Vitrual DOM에서 실제 DOM으로 이동하는 과정입니다. "**   

---
### 2024-03-20 강의 내용   
### 1. 리액트는 무엇인가?
- 사용자 인터페이스를 만들기 위한 자바스크립트 라이브러리
- 사용자와 웹사이트의 상호작용을 돕는 인터페이스를 만들기 위한 자바스크립트 기능 모음집
- **라이브러리란?** 자주 사용되는 기능을 정리해 모아 놓은 것
- **라이브러리와 프레임워크 차이** :    
-> 가장 큰 차이점은 프로그램의 *흐름에 대한 제어 권한*   
-> 프레임워크는 프레임워크, 라이브러리는 개발자

### 2. 리액트의 장점
- 빠른 업데이트와 렌더링 속도   
-> **업데이트란** 웹사이트를 탐색할 때 화면에 나타나는 내용이 바뀌는 것   
-> 빠른 업데이트를 위해 내부적으로 Virtual DOM을 사용   
-> **Virtual DOM**은 말 그대로 가상의 DOM : 웹페이지를 정의하는 하나의 객체   
- **동기식** :  
    1. 코드가 실행되면 순서대로 Call Stack에 실행할 함수가 쌓인다.  (push)

    2. 쌓인 반대 순서로 함수가 실행된다.(LIFO)

    3. 실행이 된 함수는 Call Stack에서 제거된다(pop)
- **비동기식** :  
    1. Call Stack에서 비동기 함수가 호출되면 Call Stack에 먼저 쌓였다가 Web API(혹은 백그라운드라고도 한다)로 이동한 후 해당 함수가 등록되고 Call Stack에서 사라진다.

    2. Web API(백그라운드)에서 비동기 함수의 이벤트가 발생하면, 해당 콜백 함수는 Callback Queue에 push(이동) 된다.

    3. 이제 Call Stack이 비어있는지 이벤트 루프(Event Loop)가 확인을 하는데 만약 비어있으면, Call Stack에 Callback Queue에 있는 콜백 함수를 넘겨준다.(push)

    4. Call Stack에 들어온 함수는 실행이 되고 실행이 끝나면 Call Stack에서 사라진다. 

- 컴포넌트 기반 구조   
-> 리액트의 모든 페이지는 컴포넌트로 구성   
-> 하나의 컴포넌트는 다른 여러 개의컴포넌트의 조합으로 구성할 수 있다.   
-> 그래서 리액트로 개발 하다 보면 레고 블록을 조립하는 것처럼 컴포넌트를 조합해서 웹사이트를 개발하게 된다.   
-> 재사용성이 뛰어나다.   

- 재사용성   
-> 반복적인 작업을 줄여주기 때문에 생산선을 높여줌   
-> 유지보수 용이   
-> **재사용이 가능하려면 해당 모듈의 의존성이 없어야함**


- 든든한 지원군   
-> 메타(구 페이스북)에서 오픈소스 프로젝트로 관리하고 있어 계속 발전   
-> 활발한 지식 공유 & 커뮤니티   
-> 모바일 앱 개발 가능 : 리액트 네이티브라는 모바일 환경 UI프레임워크를 사용하면 크로스 플랫폼 모바일앱을 개발 가능

### 3. 리액트의 단점
- 방대한 학습량   
-> 자바스크립트를 공부한 경우 빠르게 학습할 수 있음   
- 높은 상태 관리 복잡도   
-> state,component life cycle 등의 개념이 있지만 어렵지 않음
---
### 2024-03-13 강의 내용
### 1. GitHub 사용법
- GitHub 연동
- GitHub 커밋 및 푸쉬
### 2. JavaScript
- JavaScript란?
- ES6(ECMAScript6) - 표준 ECMA-262
- JavaScript의 자료형  
-> var : 재선언 가능, 업데이트 가능  
-> let : 재선언 불가능, 업데이트 가능  
...
- 연산자  
-> ==, === 차이  
-> 기본 자료형(Primitive) : **데이터 타입**  
-> 객체형(Object Type) : **메모리 주소**  

### 3. Node.js 설치
- 터미널 명령어 버전 확인  
-> node -v  
-> npm -v  
-> npx -v  
-> versionv, -v
---